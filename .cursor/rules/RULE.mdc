---
alwaysApply: false
---
## How You Work (Mandatory)

### 1) Codebase Review First

Before suggesting changes, inspect and reference specific files via `@` (examples: `@app/page.tsx`, `@app/api/.../route.ts`, `@status.md`). If context is missing, request it explicitly using `@` references. Do not guess file structure.

### 2) Incremental, Testable Suggestions

Provide changes in small steps. For **each step**, include:

* What change you're making + why
* Minimal code snippet (only the relevant diff)
* A targeted test (unit/integration/e2e)
* Expected outcome + edge cases

### 3) Communication Style

* **No emojis.**
* **Do not add code comments unless required** for correctness, security, or non-obvious trade-offs.
* Keep responses concise and technical.
* Prefer early returns and readable control flow.
* Avoid boilerplate.

---

## Testing Requirements (Mandatory)

### Baseline Test Suite Must Exist

If tests are missing or thin, your first recommendation must add a minimal baseline so core features don't regress.

### Required Core Feature Coverage

Maintain automated tests for these flows at minimum:

1. **Questions catalog loads**

   * list view renders from JSON source
   * category filtering works
   * empty state works
2. **Question detail page**

   * loads prompt + metadata
   * shows supported languages
3. **Code run / submission (Judge0 integration)**

   * request is sent with correct payload
   * polling / result handling works
   * handles timeouts / failures gracefully
4. **Auth gate (Firebase Auth)**

   * protected actions require auth
   * unauthenticated user sees correct UX
5. **Progress tracking (Firestore)**

   * marking complete / saving progress works
   * handles offline / retry behavior (if supported)
6. **Leaderboard**

   * displays data
   * handles ties/empty states
   * does not leak private user data

### Test Tools Guidance

* Prefer **Playwright** for end-to-end tests of core flows.
* Use **Vitest/Jest** only for small pure-function or component-unit tests.
* Mock external services (Judge0, Firebase) where appropriate, but include at least one "happy path" e2e that runs against a controlled test configuration.

### Test Output Expectations

Every change must include at least one of:

* a new test, or
* an update to an existing test,
  unless the change is purely non-functional (formatting/typos), in which case explicitly state "No test needed" and why.

---

## Performance and Robustness Requirements

* Minimize client bundles; avoid heavy dependencies unless justified.
* Minimize `use client`; favor Server Components.
* Avoid unnecessary `useEffect` and `useState`.
* Use `<Suspense>` around client components with small fallbacks.
* Use `next/dynamic` for non-critical UI (`ssr: false` only when truly client-only).
* Use `next/image` with explicit sizes and lazy loading.
* Handle failures: try/catch around external calls, user-friendly errors, structured logging.
* Use Lighthouse and/or bundle analysis when performance is in scope.

---

## Operational Standards (Production-Ready)

* Configuration via `.env.local` in dev; via Vercel env vars in prod.
* Never commit secrets.
* Prefer serverless-friendly patterns (no long-running work in request lifecycle).
* Add monitoring hooks (Sentry or equivalent) when error visibility matters.
* Consider `npm audit` and supply-chain risk for new deps.

---

## Coding Standards

* TypeScript-first, functional style (avoid classes).
* Descriptive names: `isLoading`, `hasError`.
* Handlers prefixed with `handle`.
* Tailwind-only styling unless justified.
* No speculative refactors.

---

## Clarifying Context

If needed, ask for:

* `@status.md`
* `@package.json`
* relevant route/component files
* whether App Router or Pages Router is primary
* current Firebase setup (Auth + Firestore + hosting separation)
